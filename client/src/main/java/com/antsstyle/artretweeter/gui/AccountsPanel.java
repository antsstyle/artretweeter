/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.antsstyle.artretweeter.gui;

import com.antsstyle.artretweeter.datastructures.Account;
import com.antsstyle.artretweeter.datastructures.ClientResponse;
import com.antsstyle.artretweeter.datastructures.OperationResult;
import com.antsstyle.artretweeter.datastructures.TwitterResponse;
import com.antsstyle.artretweeter.datastructures.RequestToken;
import com.antsstyle.artretweeter.datastructures.ServerResponse;
import com.antsstyle.artretweeter.datastructures.StatusJSON;
import com.antsstyle.artretweeter.datastructures.TwitterCollectionHolder;
import com.antsstyle.artretweeter.db.CoreDB;
import com.antsstyle.artretweeter.db.DBResponse;
import com.antsstyle.artretweeter.db.DBTable;
import com.antsstyle.artretweeter.db.ResultSetConversion;
import com.antsstyle.artretweeter.enumerations.StatusCode;
import com.antsstyle.artretweeter.tools.SwingTools;
import com.antsstyle.artretweeter.twitter.RESTAPI;
import static com.antsstyle.artretweeter.twitter.RESTAPI.CURRENTLY_PROCESSING;
import java.awt.Desktop;
import java.awt.Font;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import javax.swing.JEditorPane;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableModel;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 *
 * @author antss
 */
public class AccountsPanel extends javax.swing.JPanel {

    private static final Logger LOGGER = LogManager.getLogger(AccountsPanel.class);

    /**
     * Creates new form AccountsPanel
     */
    public AccountsPanel() {
        initComponents();
    }

    public void initialise() {
        DBResponse resp = CoreDB.selectFromTable(DBTable.ACCOUNTS);
        if (!resp.wasSuccessful()) {
            LOGGER.error("Failed to initialise accounts panel!");
            return;
        }
        DefaultTableModel dtm = (DefaultTableModel) accountsTable.getModel();
        ArrayList<HashMap<String, Object>> rows = resp.getReturnedRows();
        for (HashMap<String, Object> row : rows) {
            Account account = ResultSetConversion.getAccount(row);
            String query = "SELECT COUNT(*) AS C FROM tweets WHERE usertwitterid=?";
            DBResponse countResp = CoreDB.customQuerySelect(query, account.getTwitterID());
            if (!countResp.wasSuccessful()) {
                LOGGER.error("Failed to initialise accounts panel!");
                return;
            } else {
                Long count = (Long) countResp.getReturnedRows().get(0).get("C");
                if (count == null) {
                    count = 0L;
                }
                dtm.addRow(new Object[]{account.getScreenName(), count.intValue()});
            }

        }
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        accountsTable = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        addAccountButton = new javax.swing.JButton();
        removeAccountButton = new javax.swing.JButton();
        retrieveTweetsButton = new javax.swing.JButton();
        tweetDownloadProgressBar = new javax.swing.JProgressBar();
        tweetDownloadProgressBar.setVisible(false);
        tweetDownloadProgressLabel = new javax.swing.JLabel();
        retrieveCollectionsButton = new javax.swing.JButton();

        accountsTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Account Name", "Tweets Retrieved"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Integer.class
            };
            boolean[] canEdit = new boolean [] {
                false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane1.setViewportView(accountsTable);
        if (accountsTable.getColumnModel().getColumnCount() > 0) {
            accountsTable.getColumnModel().getColumn(1).setMinWidth(110);
            accountsTable.getColumnModel().getColumn(1).setPreferredWidth(110);
            accountsTable.getColumnModel().getColumn(1).setMaxWidth(110);
        }

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel1.setText("Accounts");

        addAccountButton.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        addAccountButton.setText("Add Account");
        addAccountButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addAccountButtonActionPerformed(evt);
            }
        });

        removeAccountButton.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        removeAccountButton.setText("Remove Account");
        removeAccountButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeAccountButtonActionPerformed(evt);
            }
        });

        retrieveTweetsButton.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        retrieveTweetsButton.setText("Retrieve Tweets");
        retrieveTweetsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                retrieveTweetsButtonActionPerformed(evt);
            }
        });

        tweetDownloadProgressBar.setIndeterminate(true);
        tweetDownloadProgressBar.setMaximumSize(new java.awt.Dimension(542, 40));
        tweetDownloadProgressBar.setMinimumSize(new java.awt.Dimension(542, 40));
        tweetDownloadProgressBar.setPreferredSize(new java.awt.Dimension(542, 40));

        tweetDownloadProgressLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        tweetDownloadProgressLabel.setToolTipText("");
        tweetDownloadProgressLabel.setMaximumSize(new java.awt.Dimension(542, 65));
        tweetDownloadProgressLabel.setMinimumSize(new java.awt.Dimension(542, 65));
        tweetDownloadProgressLabel.setName(""); // NOI18N
        tweetDownloadProgressLabel.setPreferredSize(new java.awt.Dimension(542, 65));

        retrieveCollectionsButton.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        retrieveCollectionsButton.setText("Retrieve Collections");
        retrieveCollectionsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                retrieveCollectionsButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 267, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(addAccountButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(removeAccountButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(retrieveTweetsButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(retrieveCollectionsButton))
                    .addComponent(jScrollPane1)
                    .addComponent(tweetDownloadProgressLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(tweetDownloadProgressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(addAccountButton)
                    .addComponent(removeAccountButton)
                    .addComponent(retrieveTweetsButton)
                    .addComponent(retrieveCollectionsButton))
                .addGap(42, 42, 42)
                .addComponent(tweetDownloadProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(tweetDownloadProgressLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(59, 59, 59))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void removeAccountButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeAccountButtonActionPerformed
        removeAccountButton.setEnabled(false);
        removeAccount();
        removeAccountButton.setEnabled(true);
    }//GEN-LAST:event_removeAccountButtonActionPerformed

    private void addAccountButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addAccountButtonActionPerformed
        addAccountButton.setEnabled(false);
        addAccount();
        addAccountButton.setEnabled(true);
    }//GEN-LAST:event_addAccountButtonActionPerformed

    private void retrieveTweetsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_retrieveTweetsButtonActionPerformed
        disableAllAccountButtons();
        retrieveTweets();
    }//GEN-LAST:event_retrieveTweetsButtonActionPerformed

    private void retrieveCollectionsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_retrieveCollectionsButtonActionPerformed
        disableAllAccountButtons();
        retrieveCollections();
    }//GEN-LAST:event_retrieveCollectionsButtonActionPerformed

    private void disableAllAccountButtons() {
        retrieveTweetsButton.setEnabled(false);
        removeAccountButton.setEnabled(false);
        addAccountButton.setEnabled(false);
        retrieveCollectionsButton.setEnabled(false);
    }

    private void enableAllAccountButtons() {
        retrieveTweetsButton.setEnabled(true);
        addAccountButton.setEnabled(true);
        retrieveCollectionsButton.setEnabled(true);
        removeAccountButton.setEnabled(true);
    }

    private void retrieveCollections() {
        int row = accountsTable.getSelectedRow();
        if (row == -1) {
            enableAllAccountButtons();
            return;
        }
        int modelRow = accountsTable.convertRowIndexToModel(row);
        int accountNameColumnIndex = accountsTable.getColumnModel().getColumnIndex("Account Name");
        String screenName = (String) accountsTable.getModel().getValueAt(modelRow, accountNameColumnIndex);
        Account account;
        DBResponse accountResp = CoreDB.selectFromTable(DBTable.ACCOUNTS,
                new String[]{"screen_name"},
                new Object[]{screenName});
        if (!accountResp.wasSuccessful()) {
            String statusMessage = "Failed to query database for access token!";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            enableAllAccountButtons();
            return;
        } else if (accountResp.getReturnedRows().isEmpty()) {
            String statusMessage = "Access token not found in database for this user!";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            enableAllAccountButtons();
            return;
        }
        account = ResultSetConversion.getAccount(accountResp.getReturnedRows().get(0));
        Path tweetFolderPath = CoreDB.getTweetFolderPath(account);
        if (tweetFolderPath == null) {
            String statusMessage = "Failed to get tweet image directory information from database!";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            enableAllAccountButtons();
            return;
        }
        try {
            Files.createDirectories(tweetFolderPath);
        } catch (Exception e) {
            LOGGER.error("Could not create tweet image base directories!", e);
            String statusMessage = "Could not create tweet image base directories!";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            enableAllAccountButtons();
            return;
        }
        String msg = "<html>Retrieving collections might take a few minutes, if you have large collections. <br/>Press OK to proceed.</html>";
        Integer result = JOptionPane.showConfirmDialog(GUI.getInstance(), msg, "Add Account", JOptionPane.OK_CANCEL_OPTION);
        if (result == JOptionPane.OK_OPTION) {
            tweetDownloadProgressLabel.setText("Retrieving... ");
            tweetDownloadProgressBar.setVisible(true);
            tweetDownloadProgressBar.setIndeterminate(false);
            ArrayList<OperationResult> errorResults = new ArrayList<>();
            SwingWorker worker = new SwingWorker<Object, Pair<Integer, Integer>>() {

                @Override
                protected Object doInBackground() {
                    OperationResult res;
                    CURRENTLY_PROCESSING = true;
                    boolean fatalError = false;
                    int errorCount = 0;
                    int successCount = 0;
                    res = RESTAPI.getCollectionsByUserID(account.getTwitterID(), account);

                    if (!res.wasSuccessful()) {
                        fatalError = true;
                        errorResults.add(res);
                        return new Object[]{fatalError, errorCount, successCount};
                    }
                    ArrayList<TwitterCollectionHolder> collections
                            = (ArrayList<TwitterCollectionHolder>) res.getTwitterResponse().getReturnedObject();
                    int count = 1;
                    int total = 1 + collections.size();
                    publish(Pair.of(count, total));
                    for (TwitterCollectionHolder collection : collections) {
                        OperationResult hydrationResult = RESTAPI.getFullyHydratedCollectionByID(collection.getTwitterID(), account);
                        if (!hydrationResult.wasSuccessful()) {
                            errorCount++;
                            errorResults.add(hydrationResult);
                        } else {
                            successCount++;
                        }
                        count++;
                        publish(Pair.of(count, total));
                    }
                    setProgress(100);
                    CURRENTLY_PROCESSING = false;
                    return new Object[]{fatalError, errorCount, successCount};

                }

                @Override
                protected void process(List<Pair<Integer, Integer>> chunks) {
                    Pair<Integer, Integer> chunk = chunks.get(chunks.size() - 1);
                    Integer count = chunk.getLeft();
                    Integer total = chunk.getRight();
                    int floorPercent = (int) (((double) count / (double) total) * 100.0);
                    tweetDownloadProgressBar.setValue(floorPercent);
                }

                @Override
                public void done() {
                    Object[] results;
                    try {
                        results = (Object[]) get();
                    } catch (Exception e) {
                        LOGGER.error("Failed to acquire results!", e);
                        tweetDownloadProgressBar.setVisible(false);
                        tweetDownloadProgressBar.setValue(0);
                        tweetDownloadProgressBar.setIndeterminate(true);
                        enableAllAccountButtons();
                        return;
                    }

                    boolean fatalError = (boolean) results[0];
                    int errorCount = (int) results[1];
                    int successCount = (int) results[2];

                    if (!fatalError && errorCount == 0) {
                        tweetDownloadProgressLabel.setText("<html>Collection retrieval finished successfully.</html>");
                    } else if (!fatalError) {
                        tweetDownloadProgressLabel.setText("<html>Retrieval completed, but some errors occurred.<br/>"
                                + String.valueOf(successCount) + " collections were retrieved successfully, "
                                + "and " + String.valueOf(errorCount) + " failed and were not retrieved." + "</html>");
                    } else {
                        tweetDownloadProgressLabel.setText("<html>A fatal error occurred - no collections were retrieved.</html>");
                        LOGGER.error("Fatal error: " + errorResults.get(0).getErrorCode().getStatusMessage());
                    }
                    tweetDownloadProgressBar.setVisible(false);
                    tweetDownloadProgressBar.setValue(0);
                    tweetDownloadProgressBar.setIndeterminate(true);
                    Account selAcc = GUI.getCollectionsPanel().getCurrentlySelectedAccount();
                    if (selAcc.getTwitterID().equals(account.getTwitterID())) {
                        GUI.getCollectionsPanel().refreshCollectionBoxModel(false);
                    }
                    enableAllAccountButtons();
                }
            };
            worker.execute();
        } else {
            enableAllAccountButtons();
        }
    }

    private void retrieveTweets() {
        int row = accountsTable.getSelectedRow();
        if (row == -1) {
            enableAllAccountButtons();
            return;
        }
        int modelRow = accountsTable.convertRowIndexToModel(row);
        int accountNameColumnIndex = accountsTable.getColumnModel().getColumnIndex("Account Name");
        int tweetsRetrievedColumnIndex = accountsTable.getColumnModel().getColumnIndex("Tweets Retrieved");
        String screenName = (String) accountsTable.getModel().getValueAt(modelRow, accountNameColumnIndex);
        Account account;
        DBResponse accountResp = CoreDB.selectFromTable(DBTable.ACCOUNTS,
                new String[]{"screen_name"},
                new Object[]{screenName});
        if (!accountResp.wasSuccessful()) {
            String statusMessage = "Failed to query database for access token!";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            enableAllAccountButtons();
            return;
        } else if (accountResp.getReturnedRows().isEmpty()) {
            String statusMessage = "Access token not found in database for this user!";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            enableAllAccountButtons();
            return;
        }
        account = ResultSetConversion.getAccount(accountResp.getReturnedRows().get(0));
        Path tweetFolderPath = CoreDB.getTweetFolderPath(account);
        if (tweetFolderPath == null) {
            String statusMessage = "Failed to get tweet image directory information from database!";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            enableAllAccountButtons();
            return;
        }
        Long highestIDInDB;
        String highestIDQuery = "SELECT MAX(tweetid) AS maxtweetid FROM tweets WHERE usertwitterid=?";
        DBResponse highestIDInDBResp = CoreDB.customQuerySelect(highestIDQuery, account.getTwitterID());
        if (!highestIDInDBResp.wasSuccessful()) {
            String statusMessage = "Failed to get highest tweet information from DB for this account!";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            enableAllAccountButtons();
            return;
        } else if (highestIDInDBResp.getReturnedRows().isEmpty()) {
            highestIDInDB = 0L;
        } else {
            highestIDInDB = (Long) highestIDInDBResp.getReturnedRows().get(0).get("MAXTWEETID");
        }
        try {
            Files.createDirectories(tweetFolderPath);
        } catch (Exception e) {
            LOGGER.error("Could not create tweet image base directories!", e);
            String statusMessage = "Could not create tweet image base directories!";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            enableAllAccountButtons();
            return;
        }
        LOGGER.debug("Tweet folder path: " + tweetFolderPath);
        Long historicalMaxID = account.getHistoricalMaxID();
        Long latestMaxID = null;
        Long finalHistoricalMaxID;
        if (historicalMaxID == null) {
            finalHistoricalMaxID = Long.MAX_VALUE;
        } else {
            finalHistoricalMaxID = historicalMaxID;
        }
        if (finalHistoricalMaxID.equals(0L)) {
            latestMaxID = account.getLatestMaxID();
            if (latestMaxID == null) {
                latestMaxID = Long.MAX_VALUE;
            }
        }
        Long finalLatestMaxID = latestMaxID;
        Long count;
        String cQuery = "SELECT COUNT(*) AS C FROM tweets WHERE usertwitterid=?";
        DBResponse countResp = CoreDB.customQuerySelect(cQuery, account.getTwitterID());
        if (!countResp.wasSuccessful()) {
            String statusMessage = "Could not retrieve previous tweet count for this user from database!";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            enableAllAccountButtons();
            return;
        } else {
            count = (Long) countResp.getReturnedRows().get(0).get("C");
            if (count == null) {
                count = 0L;
            }
        }
        final Integer countBeforeStart = count.intValue();
        String msg = "<html>Retrieving tweets may take a few minutes, depending on the size of your tweet history. "
                + "<br/><br/>Note that this might not retrieve all media tweets from your account, due to limitations of the standard Twitter API."
                + "<br/><br/>Press OK to proceed.</html>";
        Integer result = JOptionPane.showConfirmDialog(GUI.getInstance(), msg, "Add Account", JOptionPane.OK_CANCEL_OPTION);
        if (result != JOptionPane.OK_OPTION) {
            enableAllAccountButtons();
            return;
        }
        tweetDownloadProgressLabel.setText("Retrieving... ");
        tweetDownloadProgressBar.setVisible(true);
        SwingWorker worker = new SwingWorker<Object, Pair<Integer, Integer>>() {

            Integer storedTweetCount = 0;
            Integer receivedTweetCount = 0;

            @Override
            protected Object doInBackground() {
                CURRENTLY_PROCESSING = true;
                Pair<OperationResult, ArrayList<StatusJSON>> returnResults;
                ArrayList<StatusJSON> statuses = new ArrayList<>();
                Long historicalMaxID = finalHistoricalMaxID;
                Long latestMaxID = finalLatestMaxID;
                Boolean finished = false;
                OperationResult finalResult = new OperationResult();
                int consecutiveErrors = 0;
                try ( CloseableHttpClient httpclient = HttpClients.createDefault()) {
                    while (!finished) {
                        try {
                            LOGGER.debug("Params: " + historicalMaxID + " -- " + latestMaxID + " -- " + highestIDInDB);
                            returnResults = RESTAPI.getAllUnrecordedUserTweetsByDate(httpclient, account,
                                    historicalMaxID, latestMaxID, tweetFolderPath, highestIDInDB);
                            OperationResult lastResult = returnResults.getLeft();
                            finalResult = lastResult;
                            if (lastResult.wasSuccessful()) {
                                consecutiveErrors = 0;
                                ArrayList<StatusJSON> returnedStatuses = returnResults.getRight();
                                statuses.addAll(returnedStatuses);
                                Pair<Long, Long> resultPair = (Pair<Long, Long>) lastResult.getTwitterResponse().getReturnedObject();
                                if (returnedStatuses.isEmpty()) {
                                    finished = true;
                                    LOGGER.debug("No more statuses to retrieve.");
                                    if (resultPair != null) {
                                        if (!historicalMaxID.equals(0L) && latestMaxID == null) {
                                            historicalMaxID = 0L;
                                            CoreDB.updateTable(DBTable.ACCOUNTS,
                                                    new String[]{"historicalmaxid"},
                                                    new Object[]{historicalMaxID},
                                                    new String[]{"twitterid"},
                                                    new Object[]{account.getTwitterID()});
                                        } else if (historicalMaxID.equals(0L) && latestMaxID != null) {
                                            latestMaxID = resultPair.getRight();
                                            CoreDB.updateTable(DBTable.ACCOUNTS,
                                                    new String[]{"latestmaxid"},
                                                    new Object[]{latestMaxID},
                                                    new String[]{"twitterid"},
                                                    new Object[]{account.getTwitterID()});
                                        }
                                    }
                                } else {
                                    historicalMaxID = resultPair.getLeft();
                                    CoreDB.updateTable(DBTable.ACCOUNTS,
                                            new String[]{"historicalmaxid"},
                                            new Object[]{historicalMaxID},
                                            new String[]{"twitterid"},
                                            new Object[]{account.getTwitterID()});
                                }

                                storedTweetCount += lastResult.getTwitterResponse().getStoredTweetCount();
                                receivedTweetCount += lastResult.getTwitterResponse().getReceivedTweetCount();
                                publish(Pair.of(storedTweetCount, receivedTweetCount));

                            } else if (lastResult.getErrorCode().equals(StatusCode.RATE_LIMIT_EXCEEDED_ERROR)) {
                                return Pair.of(lastResult, statuses);
                            } else {
                                LOGGER.error("Error: " + lastResult.getErrorCode().toString());
                                try {
                                    Thread.sleep(10 * 1000);
                                } catch (Exception e) {
                                    LOGGER.error("Interrupted while waiting", e);
                                    finished = true;
                                }
                                consecutiveErrors++;
                                if (consecutiveErrors >= 3) {
                                    finished = true;
                                }
                            }
                        } catch (Exception e) {
                            LOGGER.error("Tweet retrieval encountered exception", e);
                            finalResult.setClientResponse(new ClientResponse(StatusCode.MISC_ERROR));
                            CURRENTLY_PROCESSING = false;
                            return Pair.of(finalResult, statuses);
                        }

                        try {
                            Thread.sleep(5 * 1000);
                        } catch (Exception e) {
                            LOGGER.info("Interrupted while waiting - aborting tweet download.");
                            break;
                        }
                    }

                    CURRENTLY_PROCESSING = false;
                    return Pair.of(finalResult, statuses);
                } catch (Exception e) {
                    LOGGER.error("Failed to create httpclient!", e);
                    finalResult.setClientResponse(new ClientResponse(StatusCode.MISC_ERROR));
                    finalResult.getClientResponse().setExtraStatusMessage("Failed to create httpclient!");
                    return Pair.of(finalResult, null);
                }
            }

            @Override
            protected void process(List<Pair<Integer, Integer>> chunks) {
                Pair<Integer, Integer> last = chunks.get(chunks.size() - 1);
                String tweetsRetrieved;
                if (last.getLeft() == 1) {
                    tweetsRetrieved = "tweet";
                } else {
                    tweetsRetrieved = "tweets";
                }
                TableModel tm = accountsTable.getModel();
                int rowCount = accountsTable.getRowCount();
                for (int i = 0; i < rowCount; i++) {
                    String tableScreenName = (String) tm.getValueAt(i, accountNameColumnIndex);
                    if (tableScreenName.equals(screenName)) {
                        Integer newRetrievedCount = last.getLeft();
                        Integer newReceivedCount = last.getRight();
                        tm.setValueAt(countBeforeStart + newRetrievedCount, i, tweetsRetrievedColumnIndex);
                        tweetDownloadProgressLabel.setText("<html>Retrieving... ".concat(String.valueOf(newRetrievedCount)).concat(" ").concat(tweetsRetrieved)
                                .concat(" added so far (out of ").concat(String.valueOf(newReceivedCount).concat(" received).</html>")));
                        break;
                    }
                }
            }

            @Override
            public void done() {
                Pair<OperationResult, ArrayList<StatusJSON>> results;
                try {
                    results = (Pair<OperationResult, ArrayList<StatusJSON>>) get();
                } catch (Exception e) {
                    LOGGER.error("Failed to acquire results!", e);
                    tweetDownloadProgressBar.setVisible(false);
                    enableAllAccountButtons();
                    return;
                }
                OperationResult res = results.getLeft();

                TableModel tm = accountsTable.getModel();
                String query = "SELECT COUNT(*) AS C FROM tweets WHERE usertwitterid=?";
                DBResponse countResp = CoreDB.customQuerySelect(query, account.getTwitterID());
                if (!countResp.wasSuccessful()) {
                    LOGGER.error("Failed to get count of user tweets!");
                    enableAllAccountButtons();
                    return;
                } else {
                    Long count = (Long) countResp.getReturnedRows().get(0).get("C");
                    if (count == null) {
                        count = 0L;
                    }
                    tm.setValueAt(count, modelRow, tweetsRetrievedColumnIndex);
                }

                StatusCode artRetweeterStatusCode = res.getTwitterResponse().getStatusCode();

                if (res.wasSuccessful()) {
                    tweetDownloadProgressLabel.setText("<html>Tweet retrieval finished successfully. "
                            + String.valueOf(storedTweetCount) + " stored, out of "
                            + String.valueOf(receivedTweetCount) + " received.</html>");
                } else if (artRetweeterStatusCode.equals(StatusCode.RATE_LIMIT_EXCEEDED_ERROR)) {
                    int resetTimeSeconds = (int) res.getTwitterResponse().getReturnedObject();
                    tweetDownloadProgressLabel.setText("<html>Twitter rate limit exceeded. You must wait " + String.valueOf(resetTimeSeconds)
                            + " before attempting to retry.</html>");
                } else if (results.getRight() != null) {
                    tweetDownloadProgressLabel.setText("<html>An error occurred, but some tweets were successfully retrieved.</html>");
                }
                tweetDownloadProgressBar.setVisible(false);
                Account selAcc = GUI.getCollectionsPanel().getCurrentlySelectedAccount();
                if (selAcc.getTwitterID().equals(account.getTwitterID())) {
                    GUI.getCollectionsPanel().refreshTweetsTable();
                }
                enableAllAccountButtons();
            }
        };
        worker.execute();

    }

    private void addAccount() {
        String query = "SELECT COUNT(*) AS C FROM accounts";
        DBResponse countResp = CoreDB.customQuerySelect(query);
        Long count;
        if (!countResp.wasSuccessful()) {
            LOGGER.error("Failed to initialise accounts panel!");
            return;
        } else {
            count = (Long) countResp.getReturnedRows().get(0).get("C");
            if (count == null) {
                count = 0L;
            }
        }
        if (count >= 2L) {
            String statusMessage = "<html>You may not add more than two accounts. Delete an existing account before adding a new one.</html>";
            JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }
        String msg = "<html>To add a new account, a browser window will be opened and directed to Twitter for authentication."
                + "<br /><br />Press OK to continue.</html>";
        Integer result = JOptionPane.showConfirmDialog(GUI.getInstance(), msg, "Add Account", JOptionPane.OK_CANCEL_OPTION);
        if (result != JOptionPane.OK_OPTION) {
            return;
        }
        OperationResult reqTokenResult = RESTAPI.oauthRequestToken();
        if (!reqTokenResult.wasSuccessful()) {
            GUIHelperMethods.showErrors(reqTokenResult, LOGGER, null);
            return;
        }
        RequestToken token = (RequestToken) reqTokenResult.getTwitterResponse().getReturnedObject();
        if (token == null) {
            return;
        }

        String authURL = "https://api.twitter.com/oauth/authorize?oauth_token=".concat(token.getToken());
        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(authURL));
            } catch (Exception e) {
                LOGGER.error("Unable to direct user to auth URL.", e);
                showAuthenticationURL(authURL);
            }
        } else {
            showAuthenticationURL(authURL);
        }

        boolean cancel = false;
        ArrayList<Object> results = null;
        while (results == null) {
            results = SwingTools.askForUserInput("Enter PIN",
                    "Please enter the PIN shown on the Twitter authentication page.", "PIN:");
            if (results == null) {
                String confirmCancel = "<html>Do you want to cancel adding this account?<br/><br/>"
                        + "Select <b>Yes</b> to go back to entering the PIN, or <b>No</b> to cancel account addition.</html>";
                Integer cancelResult = JOptionPane.showConfirmDialog(GUI.getInstance(), confirmCancel,
                        "Cancel Account Addition", JOptionPane.YES_NO_OPTION);
                if (cancelResult != JOptionPane.YES_OPTION) {
                    cancel = true;
                }
            }
            if (cancel) {
                return;
            }
        }

        String pin = (String) results.get(0);
        OperationResult authResult = RESTAPI.oauthAccessToken(pin, token);
        if (!authResult.wasSuccessful()) {
            GUIHelperMethods.showErrors(reqTokenResult, LOGGER, null);
            return;
        }

        Account account = (Account) authResult.getTwitterResponse().getReturnedObject();
        CoreDB.addAccountToDB(account);
        DefaultTableModel dtm = (DefaultTableModel) accountsTable.getModel();
        dtm.addRow(new Object[]{account.getScreenName(), 0});
        GUI.getCollectionsPanel().refreshAccountBoxModel(false);
        String statusMessage = "<html>Account added successfully!</html>";
        JOptionPane.showMessageDialog(GUI.getInstance(), statusMessage, "Success", JOptionPane.INFORMATION_MESSAGE);
    }

    private void showAuthenticationURL(String authURL) {
        Font font = new Font("Dialog", Font.PLAIN, 12);

        StringBuffer style = new StringBuffer("font-family:" + font.getFamily() + ";");
        style.append("font-weight:").append(font.isBold() ? "bold" : "normal").append(";");
        style.append("font-size:").append(font.getSize()).append("pt;");

        JEditorPane ep = new JEditorPane("text/html", "<html><body style=\"" + style + "\">"
                + "Failed to open an Internet browser to authenticate. Please go to this URL to continue authentication: " + authURL
                + "</body></html>");

        ep.setEditable(false);

        JOptionPane.showMessageDialog(GUI.getInstance(), ep, "Authentication", JOptionPane.INFORMATION_MESSAGE);
    }

    private void removeAccount() {
        int row = accountsTable.getSelectedRow();
        if (row == -1) {
            return;
        }
        int modelRow = accountsTable.convertRowIndexToModel(row);
        int accountNameColumnIndex = accountsTable.getColumnModel().getColumnIndex("Account Name");
        String screenName = (String) accountsTable.getModel().getValueAt(modelRow, accountNameColumnIndex);

        DBResponse accountResp = CoreDB.selectFromTable(DBTable.ACCOUNTS,
                new String[]{"screen_name"},
                new Object[]{screenName});
        if (!accountResp.wasSuccessful()) {

        } else if (accountResp.getReturnedRows().isEmpty()) {

        }

        Account account = ResultSetConversion.getAccount(accountResp.getReturnedRows().get(0));

        String confirmDelete = "<html>Are you sure you want to delete account '" + screenName
                + "' from ArtRetweeter? This action cannot be undone.<br/><br/>"
                + "Note that this method does not revoke access to this application. "
                + "To do that, you must log into the Twitter<br/>website and go to Settings->Security and "
                + "account access->Apps and sessions to revoke permissions."
                + "</html>";
        Integer deleteResult = JOptionPane.showConfirmDialog(GUI.getInstance(), confirmDelete,
                "Delete Account", JOptionPane.YES_NO_OPTION);
        if (deleteResult != JOptionPane.YES_OPTION) {
            return;
        }
        String deleteQuery = "DELETE FROM retweetsqueue WHERE internalaccountid=?";
        CoreDB.runCustomUpdate(deleteQuery, new Object[]{account.getId()});
        deleteQuery = "DELETE FROM tweets WHERE usertwitterid=? "
                + " AND tweetid NOT IN (SELECT tweetid FROM collections WHERE usertwitterid != ?)";
        CoreDB.runCustomUpdate(deleteQuery, new Object[]{account.getTwitterID(), account.getTwitterID()});
        deleteQuery = "DELETE FROM accounts WHERE id=?";
        CoreDB.runCustomUpdate(deleteQuery, new Object[]{account.getId()});

    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable accountsTable;
    private javax.swing.JButton addAccountButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton removeAccountButton;
    private javax.swing.JButton retrieveCollectionsButton;
    private javax.swing.JButton retrieveTweetsButton;
    private javax.swing.JProgressBar tweetDownloadProgressBar;
    private javax.swing.JLabel tweetDownloadProgressLabel;
    // End of variables declaration//GEN-END:variables
}
